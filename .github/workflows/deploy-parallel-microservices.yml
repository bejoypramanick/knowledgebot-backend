name: Build and Deploy All Micro-Services

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      force_rebuild_all:
        description: 'Force rebuild all services (ignore change detection)'
        required: false
        default: 'false'
        type: boolean

env:
  AWS_REGION: ap-south-1
  ECR_REGISTRY: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.ap-south-1.amazonaws.com
  ECR_REPOSITORY_PREFIX: knowledgebot

jobs:
  # Detect changes and determine what needs to be rebuilt
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      changed-layers: ${{ steps.changes.outputs.layers }}
      changed-services: ${{ steps.changes.outputs.services }}
      has-changes: ${{ steps.changes.outputs.has-changes }}
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0  # Fetch full history for proper diff

    - name: Detect changes
      id: changes
      run: |
        echo "🔍 Detecting changes since last deployment..."
        
        # Check if force rebuild is requested
        if [ "${{ github.event.inputs.force_rebuild_all }}" = "true" ]; then
          echo "🔄 Force rebuild requested, rebuilding everything"
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "changed-layers=base-layer,core-layer,database-layer,ml-layer,pdf-processor-layer,easyocr-layer,table-detector-layer,docling-core-layer,docling-full-layer" >> $GITHUB_OUTPUT
          echo "changed-services=presigned-url,s3-reader,pinecone-search,pinecone-upsert,neo4j-search,neo4j-write,dynamodb-crud,text-chunker,embedding-generator,rag-search,chat-generator,pdf-processor,easyocr,table-detector,docling-core,docling-full" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Get the last successful deployment commit
        LAST_DEPLOYMENT=$(git log --oneline --grep="Deploy" --grep="deploy" --grep="Deployment" --grep="deploy-microservices" --grep="deploy-parallel" -i -n 1 --format="%H" || echo "")
        
        # If no previous deployment found, or if we're on the same commit, rebuild everything
        if [ -z "$LAST_DEPLOYMENT" ] || [ "$LAST_DEPLOYMENT" = "$(git rev-parse HEAD)" ]; then
          echo "No previous deployment found or same commit, rebuilding everything"
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "changed-layers=base-layer,core-layer,database-layer,ml-layer,pdf-processor-layer,easyocr-layer,table-detector-layer,docling-core-layer,docling-full-layer" >> $GITHUB_OUTPUT
          echo "changed-services=presigned-url,s3-reader,pinecone-search,pinecone-upsert,neo4j-search,neo4j-write,dynamodb-crud,text-chunker,embedding-generator,rag-search,chat-generator,pdf-processor,easyocr,table-detector,docling-core,docling-full" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "Last deployment commit: $LAST_DEPLOYMENT"
        echo "Current commit: $(git rev-parse HEAD)"
        
        # Get changed files
        CHANGED_FILES=$(git diff --name-only $LAST_DEPLOYMENT..HEAD)
        echo "Changed files:"
        echo "$CHANGED_FILES"
        
        # If no files changed, still rebuild everything (safety measure)
        if [ -z "$CHANGED_FILES" ]; then
          echo "No files changed since last deployment, rebuilding everything for safety"
          echo "has-changes=true" >> $GITHUB_OUTPUT
          echo "changed-layers=base-layer,core-layer,database-layer,ml-layer,pdf-processor-layer,easyocr-layer,table-detector-layer,docling-core-layer,docling-full-layer" >> $GITHUB_OUTPUT
          echo "changed-services=presigned-url,s3-reader,pinecone-search,pinecone-upsert,neo4j-search,neo4j-write,dynamodb-crud,text-chunker,embedding-generator,rag-search,chat-generator,pdf-processor,easyocr,table-detector,docling-core,docling-full" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        # Initialize arrays
        CHANGED_LAYERS=""
        CHANGED_SERVICES=""
        HAS_CHANGES="false"
        
        # Check for layer changes
        if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile\."; then
          echo "📦 Layer Dockerfiles changed"
          HAS_CHANGES="true"
          
          # Map specific layer changes
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.base-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,base-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,presigned-url,text-chunker"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.core-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,core-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,s3-reader,dynamodb-crud"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.database-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,database-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,pinecone-search,pinecone-upsert,neo4j-search,neo4j-write"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.ml-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,ml-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,embedding-generator,rag-search,chat-generator"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.pdf-processor-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,pdf-processor-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,pdf-processor"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.easyocr-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,easyocr-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,easyocr"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.table-detector-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,table-detector-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,table-detector"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.docling-core-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,docling-core-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,docling-core"
          fi
          if echo "$CHANGED_FILES" | grep -q "layers/Dockerfile.docling-full-layer"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,docling-full-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,docling-full"
          fi
        fi
        
        # Check for requirements file changes
        if echo "$CHANGED_FILES" | grep -q "requirements-.*\.txt"; then
          echo "📋 Requirements files changed"
          HAS_CHANGES="true"
          
          # Map requirements changes to layers
          if echo "$CHANGED_FILES" | grep -q "requirements-base-layer.txt"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,base-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,presigned-url,text-chunker"
          fi
          if echo "$CHANGED_FILES" | grep -q "requirements-core-layer.txt"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,core-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,s3-reader,dynamodb-crud"
          fi
          if echo "$CHANGED_FILES" | grep -q "requirements-database-layer.txt"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,database-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,pinecone-search,pinecone-upsert,neo4j-search,neo4j-write"
          fi
          if echo "$CHANGED_FILES" | grep -q "requirements-ml-layer.txt"; then
            CHANGED_LAYERS="$CHANGED_LAYERS,ml-layer"
            CHANGED_SERVICES="$CHANGED_SERVICES,embedding-generator,rag-search,chat-generator"
          fi
        fi
        
        # Check for service-specific changes
        if echo "$CHANGED_FILES" | grep -q "Dockerfile\..*-layered"; then
          echo "🐳 Service Dockerfiles changed"
          HAS_CHANGES="true"
          
          # Map specific service changes
          for file in $(echo "$CHANGED_FILES" | grep "Dockerfile\..*-layered"); do
            service_name=$(echo "$file" | sed 's/Dockerfile\.\(.*\)-layered/\1/')
            CHANGED_SERVICES="$CHANGED_SERVICES,$service_name"
          done
        fi
        
        # Check for handler changes
        if echo "$CHANGED_FILES" | grep -q "microservices/.*-handler\.py"; then
          echo "🐍 Handler files changed"
          HAS_CHANGES="true"
          
          # Map handler changes to services
          for file in $(echo "$CHANGED_FILES" | grep "microservices/.*-handler\.py"); do
            service_name=$(echo "$file" | sed 's/microservices\/\(.*\)-handler\.py/\1/')
            CHANGED_SERVICES="$CHANGED_SERVICES,$service_name"
          done
        fi
        
        # Check for shared files that affect all services
        if echo "$CHANGED_FILES" | grep -qE "(agent-toolkit/|\.github/workflows/)"; then
          echo "🔧 Shared files changed, rebuilding all services"
          HAS_CHANGES="true"
          CHANGED_SERVICES="presigned-url,s3-reader,pinecone-search,pinecone-upsert,neo4j-search,neo4j-write,dynamodb-crud,text-chunker,embedding-generator,rag-search,chat-generator,pdf-processor,easyocr,table-detector,docling-core,docling-full"
        fi
        
        # Clean up comma-separated lists
        CHANGED_LAYERS=$(echo "$CHANGED_LAYERS" | sed 's/^,//' | sed 's/,,/,/g')
        CHANGED_SERVICES=$(echo "$CHANGED_SERVICES" | sed 's/^,//' | sed 's/,,/,/g')
        
        # Output results
        echo "has-changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
        echo "changed-layers=$CHANGED_LAYERS" >> $GITHUB_OUTPUT
        echo "changed-services=$CHANGED_SERVICES" >> $GITHUB_OUTPUT
        
        echo "📊 Change Summary:"
        echo "  Has changes: $HAS_CHANGES"
        echo "  Changed layers: $CHANGED_LAYERS"
        echo "  Changed services: $CHANGED_SERVICES"

  # Build changed layers in parallel
  build-layers:
    runs-on: ubuntu-latest
    environment: chatbot
    needs: detect-changes
    if: needs.detect-changes.outputs.has-changes == 'true'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Build changed layers
      env:
        CHANGED_LAYERS: ${{ needs.detect-changes.outputs.changed-layers }}
      run: |
        echo "🔍 Building only changed layers: $CHANGED_LAYERS"
        
        # Define layer configurations
        declare -A LAYER_CONFIGS
        LAYER_CONFIGS[base-layer]="layers/Dockerfile.base-layer:~50MB"
        LAYER_CONFIGS[core-layer]="layers/Dockerfile.core-layer:~80MB"
        LAYER_CONFIGS[database-layer]="layers/Dockerfile.database-layer:~150MB"
        LAYER_CONFIGS[ml-layer]="layers/Dockerfile.ml-layer:~400MB"
        LAYER_CONFIGS[pdf-processor-layer]="layers/Dockerfile.pdf-processor-layer:~200MB"
        LAYER_CONFIGS[easyocr-layer]="layers/Dockerfile.easyocr-layer:~300MB"
        LAYER_CONFIGS[table-detector-layer]="layers/Dockerfile.table-detector-layer:~400MB"
        LAYER_CONFIGS[docling-core-layer]="layers/Dockerfile.docling-core-layer:~500MB"
        LAYER_CONFIGS[docling-full-layer]="layers/Dockerfile.docling-full-layer:~1.2GB"
        
        # Configure AWS credentials
        aws configure set aws_access_key_id ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws configure set aws_secret_access_key ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws configure set default.region ${{ env.AWS_REGION }}
        
        # Login to ECR
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ env.ECR_REGISTRY }}
        
        # Build each changed layer
        IFS=',' read -ra LAYERS <<< "$CHANGED_LAYERS"
        for layer in "${LAYERS[@]}"; do
          if [ -n "$layer" ] && [ "${LAYER_CONFIGS[$layer]+_}" ]; then
            echo "📦 Building layer: $layer"
            dockerfile=$(echo "${LAYER_CONFIGS[$layer]}" | cut -d':' -f1)
            size=$(echo "${LAYER_CONFIGS[$layer]}" | cut -d':' -f2)
            
            # Build and push the layer
            docker build -f "$dockerfile" -t "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-$layer:${{ github.sha }}" .
            docker push "${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-$layer:${{ github.sha }}"
            
            echo "✅ Built and pushed $layer ($size)"
          fi
        done
        
        echo "🎉 All changed layers built successfully"

  # Build changed services in parallel after layers are ready
  build-services:
    needs: [detect-changes, build-layers]
    runs-on: ubuntu-latest
    environment: chatbot
    if: needs.detect-changes.outputs.has-changes == 'true'
    strategy:
      max-parallel: 3
      matrix:
        include:
          # Core Micro-Services
          - name: presigned-url
            dockerfile: Dockerfile.presigned-url-layered
            base_layer: base-layer
            size: "~55MB"
            memory: 256
            timeout: 30
          - name: s3-reader
            dockerfile: Dockerfile.s3-reader-layered
            base_layer: core-layer
            size: "~85MB"
            memory: 256
            timeout: 30
          - name: pinecone-search
            dockerfile: Dockerfile.pinecone-search-layered
            base_layer: database-layer
            size: "~155MB"
            memory: 512
            timeout: 60
          - name: pinecone-upsert
            dockerfile: Dockerfile.pinecone-upsert-layered
            base_layer: database-layer
            size: "~155MB"
            memory: 512
            timeout: 60
          - name: neo4j-search
            dockerfile: Dockerfile.neo4j-search-layered
            base_layer: database-layer
            size: "~155MB"
            memory: 512
            timeout: 60
          - name: neo4j-write
            dockerfile: Dockerfile.neo4j-write-layered
            base_layer: database-layer
            size: "~155MB"
            memory: 512
            timeout: 60
          - name: dynamodb-crud
            dockerfile: Dockerfile.dynamodb-crud-layered
            base_layer: core-layer
            size: "~85MB"
            memory: 256
            timeout: 30
          - name: text-chunker
            dockerfile: Dockerfile.text-chunker-layered
            base_layer: base-layer
            size: "~55MB"
            memory: 256
            timeout: 30
          - name: embedding-generator
            dockerfile: Dockerfile.embedding-generator-layered
            base_layer: ml-layer
            size: "~405MB"
            memory: 1024
            timeout: 120
          - name: rag-search
            dockerfile: Dockerfile.rag-search-layered
            base_layer: ml-layer
            size: "~405MB"
            memory: 1024
            timeout: 180
          - name: chat-generator
            dockerfile: Dockerfile.chat-generator-layered
            base_layer: ml-layer
            size: "~405MB"
            memory: 1024
            timeout: 300
          
          # Granular OCR Micro-Services
          - name: pdf-processor
            dockerfile: Dockerfile.pdf-processor-layered
            base_layer: pdf-processor-layer
            size: "~255MB"
            memory: 1024
            timeout: 120
          - name: easyocr
            dockerfile: Dockerfile.easyocr-layered
            base_layer: easyocr-layer
            size: "~355MB"
            memory: 1024
            timeout: 180
          - name: table-detector
            dockerfile: Dockerfile.table-detector-layered
            base_layer: table-detector-layer
            size: "~455MB"
            memory: 1024
            timeout: 240
          - name: docling-core
            dockerfile: Dockerfile.docling-core-layered
            base_layer: docling-core-layer
            size: "~555MB"
            memory: 1024
            timeout: 300
          - name: docling-full
            dockerfile: Dockerfile.docling-full-layered
            base_layer: docling-full-layer
            size: "~1.25GB"
            memory: 2048
            timeout: 900
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Ensure ECR Repository Exists
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
      run: |
        echo "🔍 Ensuring ECR repository exists for base layer: ${{ matrix.base_layer }}"
        
        # Check if repository exists, create if it doesn't
        if ! aws ecr describe-repositories --repository-names $ECR_REPOSITORY_PREFIX-${{ matrix.base_layer }} --region $AWS_REGION >/dev/null 2>&1; then
          echo "📦 Creating ECR repository: $ECR_REPOSITORY_PREFIX-${{ matrix.base_layer }}"
          aws ecr create-repository \
            --repository-name $ECR_REPOSITORY_PREFIX-${{ matrix.base_layer }} \
            --region $AWS_REGION \
            --image-scanning-configuration scanOnPush=true
        else
          echo "✅ ECR repository already exists: $ECR_REPOSITORY_PREFIX-${{ matrix.base_layer }}"
        fi

    - name: Build Service ${{ matrix.name }}
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        echo "📦 Building service: ${{ matrix.name }} using ${{ matrix.base_layer }}"
        
        # Import the base layer from ECR with retry mechanism
        max_retries=5
        retry_count=0
        
        while [ $retry_count -lt $max_retries ]; do
          echo "🔄 Attempting to pull base layer (attempt $((retry_count + 1))/$max_retries)..."
          
          if docker pull $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.base_layer }}:latest; then
            echo "✅ Successfully pulled base layer"
            break
          else
            retry_count=$((retry_count + 1))
            if [ $retry_count -lt $max_retries ]; then
              echo "⏳ Waiting 30 seconds before retry..."
              sleep 30
            else
              echo "❌ Failed to pull base layer after $max_retries attempts"
              exit 1
            fi
          fi
        done
        
        # Tag it locally for the build
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.base_layer }}:latest knowledgebot-${{ matrix.base_layer }}:latest
        
        # Build the service using the imported layer
        docker build -f ${{ matrix.dockerfile }} -t $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.name }}:$IMAGE_TAG .
        
        # Tag as latest
        docker tag $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.name }}:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.name }}:latest
        
        # Push both tags
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.name }}:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.name }}:latest
        
        echo "✅ Built and pushed service: ${{ matrix.name }}"

    - name: Deploy Service ${{ matrix.name }}
      if: github.ref == 'refs/heads/main'
      env:
        IMAGE_URI: ${{ env.ECR_REGISTRY }}/${{ env.ECR_REPOSITORY_PREFIX }}-${{ matrix.name }}:${{ github.sha }}
      run: |
        echo "🚀 Deploying ${{ matrix.name }} microservice"
        
        # Check if function exists
        if aws lambda get-function --function-name knowledgebot-${{ matrix.name }} >/dev/null 2>&1; then
          echo "🔄 Updating existing microservice: knowledgebot-${{ matrix.name }}"
          
          # Update function code with retry logic
          echo "🔄 Updating function code..."
          for attempt in 1 2 3; do
            echo "Attempt $attempt of 3"
            if aws lambda update-function-code \
              --function-name knowledgebot-${{ matrix.name }} \
              --image-uri $IMAGE_URI \
              --region $AWS_REGION; then
              echo "✅ Function code updated successfully"
              break
            fi
            
            if [ $attempt -lt 3 ]; then
              echo "⏳ Waiting 30 seconds before retry..."
              sleep 30
            else
              echo "❌ Failed to update function code after 3 attempts"
              exit 1
            fi
          done
          
          # Set environment variables based on service type
          case "${{ matrix.name }}" in
            "presigned-url")
              ENV_VARS=""
              ;;
            "pinecone-search"|"pinecone-upsert")
              ENV_VARS="PINECONE_API_KEY=${{ secrets.PINECONE_API_KEY }},PINECONE_INDEX_NAME=${{ secrets.PINECONE_INDEX_NAME }},PINECONE_HOST=${{ secrets.PINECONE_HOST }},PINECONE_DIMENSIONS=${{ secrets.PINECONE_DIMENSIONS }},PINECONE_ENVIRONMENT=${{ secrets.PINECONE_ENVIRONMENT }},PINECONE_METRIC=${{ secrets.PINECONE_METRIC }}"
              ;;
            "neo4j-search"|"neo4j-write")
              ENV_VARS="NEO4J_URI=${{ secrets.NEO4J_URI }},NEO4J_USER=${{ secrets.NEO4J_USER }},NEO4J_PASSWORD=${{ secrets.NEO4J_PASSWORD }}"
              ;;
            "embedding-generator")
              ENV_VARS="OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
              ;;
            "rag-search")
              ENV_VARS=""
              ;;
            "chat-generator")
              ENV_VARS="OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
              ;;
            *)
              ENV_VARS=""
              ;;
          esac
          
          # Update function configuration with retry logic
          echo "🔄 Updating function configuration..."
          for attempt in 1 2 3; do
            echo "Attempt $attempt of 3"
            if [ -n "$ENV_VARS" ]; then
              if aws lambda update-function-configuration \
                --function-name knowledgebot-${{ matrix.name }} \
                --memory-size ${{ matrix.memory }} \
                --timeout ${{ matrix.timeout }} \
                --environment Variables="{$ENV_VARS}" \
                --region $AWS_REGION; then
                echo "✅ Function configuration updated successfully"
                break
              fi
            else
              if aws lambda update-function-configuration \
                --function-name knowledgebot-${{ matrix.name }} \
                --memory-size ${{ matrix.memory }} \
                --timeout ${{ matrix.timeout }} \
                --region $AWS_REGION; then
                echo "✅ Function configuration updated successfully"
                break
              fi
            fi
            
            if [ $attempt -lt 3 ]; then
              echo "⏳ Waiting 30 seconds before retry..."
              sleep 30
            else
              echo "❌ Failed to update function configuration after 3 attempts"
              exit 1
            fi
          done
        else
          echo "🆕 Creating new microservice: knowledgebot-${{ matrix.name }}"
          
          # Set environment variables based on service type
          case "${{ matrix.name }}" in
            "presigned-url")
              ENV_VARS=""
              ;;
            "pinecone-search"|"pinecone-upsert")
              ENV_VARS="PINECONE_API_KEY=${{ secrets.PINECONE_API_KEY }},PINECONE_INDEX_NAME=${{ secrets.PINECONE_INDEX_NAME }},PINECONE_HOST=${{ secrets.PINECONE_HOST }},PINECONE_DIMENSIONS=${{ secrets.PINECONE_DIMENSIONS }},PINECONE_ENVIRONMENT=${{ secrets.PINECONE_ENVIRONMENT }},PINECONE_METRIC=${{ secrets.PINECONE_METRIC }}"
              ;;
            "neo4j-search"|"neo4j-write")
              ENV_VARS="NEO4J_URI=${{ secrets.NEO4J_URI }},NEO4J_USER=${{ secrets.NEO4J_USER }},NEO4J_PASSWORD=${{ secrets.NEO4J_PASSWORD }}"
              ;;
            "embedding-generator")
              ENV_VARS="OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
              ;;
            "rag-search")
              ENV_VARS=""
              ;;
            "chat-generator")
              ENV_VARS="OPENAI_API_KEY=${{ secrets.OPENAI_API_KEY }}"
              ;;
            *)
              ENV_VARS=""
              ;;
          esac
          
          # Create new function
          if [ -n "$ENV_VARS" ]; then
            aws lambda create-function \
              --function-name knowledgebot-${{ matrix.name }} \
              --package-type Image \
              --code ImageUri=$IMAGE_URI \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/lambda-execution-role \
              --memory-size ${{ matrix.memory }} \
              --timeout ${{ matrix.timeout }} \
              --environment Variables="{$ENV_VARS}"
          else
            aws lambda create-function \
              --function-name knowledgebot-${{ matrix.name }} \
              --package-type Image \
              --code ImageUri=$IMAGE_URI \
              --role arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/lambda-execution-role \
              --memory-size ${{ matrix.memory }} \
              --timeout ${{ matrix.timeout }}
          fi
        fi
        
        echo "✅ Deployed knowledgebot-${{ matrix.name }} successfully"

    - name: Output build details
      run: |
        echo "📦 Service: $ECR_REGISTRY/$ECR_REPOSITORY_PREFIX-${{ matrix.name }}:$IMAGE_TAG"
        echo "📏 Size: ${{ matrix.size }}"
        echo "💾 Memory: ${{ matrix.memory }}MB"
        echo "⏱️ Timeout: ${{ matrix.timeout }}s"

  # Summary job
  deployment-summary:
    needs: [build-layers, build-services]
    runs-on: ubuntu-latest
    environment: chatbot
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Single Job Parallel Architecture Deployment Summary
      run: |
        echo "🎉 KnowledgeBot Single Job Parallel Micro-Services Deployment Complete!"
        echo ""
        echo "🏗️ Layers Built (9 layers):"
        echo "  • knowledgebot-base-layer (~50MB)"
        echo "  • knowledgebot-core-layer (~80MB)"
        echo "  • knowledgebot-database-layer (~150MB)"
        echo "  • knowledgebot-ml-layer (~400MB)"
        echo "  • knowledgebot-pdf-processor-layer (~200MB)"
        echo "  • knowledgebot-easyocr-layer (~300MB)"
        echo "  • knowledgebot-table-detector-layer (~400MB)"
        echo "  • knowledgebot-docling-core-layer (~500MB)"
        echo "  • knowledgebot-docling-full-layer (~1.2GB)"
        echo ""
        echo "📋 Micro-Services Deployed (16 services):"
        echo ""
        echo "🔧 Core Services:"
        echo "  • knowledgebot-presigned-url (256MB, 30s, ~55MB)"
        echo "  • knowledgebot-s3-reader (256MB, 30s, ~85MB)"
        echo "  • knowledgebot-pinecone-search (512MB, 60s, ~155MB)"
        echo "  • knowledgebot-pinecone-upsert (512MB, 60s, ~155MB)"
        echo "  • knowledgebot-neo4j-search (512MB, 60s, ~155MB)"
        echo "  • knowledgebot-neo4j-write (512MB, 60s, ~155MB)"
        echo "  • knowledgebot-dynamodb-crud (256MB, 30s, ~85MB)"
        echo "  • knowledgebot-text-chunker (256MB, 30s, ~55MB)"
        echo "  • knowledgebot-embedding-generator (1024MB, 120s, ~405MB)"
        echo "  • knowledgebot-rag-search (1024MB, 180s, ~405MB)"
        echo "  • knowledgebot-chat-generator (1024MB, 300s, ~405MB)"
        echo ""
        echo "📄 Granular OCR Services:"
        echo "  • knowledgebot-pdf-processor (1024MB, 120s, ~255MB)"
        echo "  • knowledgebot-easyocr (1024MB, 180s, ~355MB)"
        echo "  • knowledgebot-table-detector (1024MB, 240s, ~455MB)"
        echo "  • knowledgebot-docling-core (1024MB, 300s, ~555MB)"
        echo "  • knowledgebot-docling-full (2048MB, 900s, ~1.25GB)"
        echo ""
        echo "⚡ Single Job Parallel Processing Benefits:"
        echo "  • All 25 builds run simultaneously in one job"
        echo "  • No sequential dependencies between jobs"
        echo "  • Maximum GitHub Actions parallelism"
        echo "  • Fastest possible deployment"
        echo "  • Zero redundancy through ECR imports"
        echo "  • Build and deploy in same parallel child jobs"
        echo ""
        echo "📊 Total Architecture:"
        echo "  • Total Layers: 9 (~3.2GB)"
        echo "  • Total Services: 16 (~4.1GB)"
        echo "  • Total Storage: ~7.3GB"
        echo "  • Build Time: ~15 minutes (all parallel)"
        echo "  • Redundancy: 0% (shared layers)"
        echo ""
        echo "🔗 ECR Repositories:"
        echo "  • Registry: ${{ env.ECR_REGISTRY }}"
        echo "  • Prefix: ${{ env.ECR_REPOSITORY_PREFIX }}"
        echo "  • Total Images: 25 (9 layers + 16 services)"
